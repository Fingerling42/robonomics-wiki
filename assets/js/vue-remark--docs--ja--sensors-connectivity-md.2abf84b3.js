(window.webpackJsonp=window.webpackJsonp||[]).push([[206],{UQSp:function(t,e,o){"use strict";e.a={name:"VueRemarkRoot",render:function(t){return t("div",null,this.$slots.default)}}},byCt:function(t,e,o){"use strict";o.r(e);var n=o("KHd+"),a=o("UQSp"),i=o("Kw5r");function s(t){return(s="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}i.a.config.optionMergeStrategies;var r={VueRemarkRoot:a.a},c=function(t){var e=t.options.components=t.options.components||{},o=t.options.computed=t.options.computed||{};Object.keys(r).forEach((function(t){"object"===s(r[t])&&"function"==typeof r[t].render||"function"==typeof r[t]&&"function"==typeof r[t].options.render?e[t]=r[t]:o[t]=function(){return r[t]}}))},l=i.a.config.optionMergeStrategies,p="__vueRemarkFrontMatter",d={excerpt:null,title:"Sensors Connectivity",contributors:["Vourhey"],translated:!0};var u=function(t){t.options[p]&&(t.options[p]=d),i.a.util.defineReactive(t.options,p,d),t.options.computed=l.computed({$frontmatter:function(){return t.options[p]}},t.options.computed)},f=Object(n.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("VueRemarkRoot",[o("p",[t._v("This Aira package allows you to read data from a SDS011 sensor and publish to different output channels. That said Aira is able to form a json formatted message with measurements and publish to a few channels. Also it includes Datalog feature which is still experimental. It could be used to publish data to Substrate based blockchain by Robonomics.")]),o("p",[t._v("The last release is "),o("a",{attrs:{href:"https://github.com/airalab/sensors-connectivity/releases/tag/v0.2",target:"_blank",rel:"nofollow noopener noreferrer"}},[t._v("Sensors Connectivity v0.2")])]),o("h2",{attrs:{id:"sensor-connectivity-protocol--v1"}},[o("a",{attrs:{href:"#sensor-connectivity-protocol--v1","aria-hidden":"true"}},[o("span",{staticClass:"icon icon-link"})]),t._v("Sensor Connectivity Protocol :: v1")]),o("h3",{attrs:{id:"sensor-to-station"}},[o("a",{attrs:{href:"#sensor-to-station","aria-hidden":"true"}},[o("span",{staticClass:"icon icon-link"})]),t._v("Sensor to Station")]),o("p",[o("strong",[t._v("TCP Session diagram")])]),o("table",[o("thead",[o("tr",[o("th",[t._v("HEADER")]),o("th",[t._v("DATA1")]),o("th",[t._v("DATA2")]),o("th",[t._v("DATA3")]),o("th",[t._v("...")]),o("th",[t._v("DATAN")])])]),o("tbody")]),o("p",[t._v("where "),o("code",{pre:!0},[t._v("HEADER")]),t._v(" is 34 bytes")]),o("table",[o("thead",[o("tr",[o("th"),o("th",[t._v("Name")])])]),o("tbody",[o("tr",[o("td",[t._v("0x00")]),o("td",[t._v("public_id")])]),o("tr",[o("td",[t._v("0x20")]),o("td",[t._v("codec_id")])])])]),o("ul",[o("li",[o("code",{pre:!0},[t._v("public_id")]),t._v(" - Public identifier, generated on sensor setup.")]),o("li",[o("code",{pre:!0},[t._v("codec_id")]),t._v(" - Type of used data codec.")])]),o("p",[o("strong",[t._v("Data frame")])]),o("table",[o("thead",[o("tr",[o("th"),o("th",[t._v("Name")])])]),o("tbody",[o("tr",[o("td",[t._v("0x22")]),o("td",[t._v("payload")])]),o("tr",[o("td",[t._v("0xNN")]),o("td",[t._v("signature")])])])]),o("ul",[o("li",[o("code",{pre:!0},[t._v("payload")]),t._v(" - Sensor measurements.")]),o("li",[o("code",{pre:!0},[t._v("signature")]),t._v(" - Measurement Ed25519 signature, 64 bytes long. ("),o("a",{attrs:{href:"https://github.com/pyca/pynacl",target:"_blank",rel:"nofollow noopener noreferrer"}},[t._v("pynacl")]),t._v(")")])]),o("p",[t._v("For SDS011 sensor "),o("code",{pre:!0},[t._v("payload")]),t._v(" consists of 4 float numbers: PM2.5, PM10, GEO_LAT, GEO_LON")]),o("h3",{attrs:{id:"station-to-robonomics"}},[o("a",{attrs:{href:"#station-to-robonomics","aria-hidden":"true"}},[o("span",{staticClass:"icon icon-link"})]),t._v("Station to Robonomics")]),o("p",[t._v("The default output channel is Robonomics protocol over IPFS pubsub. For every measurement connectivity produces the following json formatted string:")]),o("pre",[o("code",{pre:!0},[t._v('{public_id: {"model": codec_id,"timestamp": unix_timestamp, "measurement": {"pm25": PM2.5, "pm10": PM10, "geo": "GEO_LAT,GEO_LON"}}}\n')])]),o("h2",{attrs:{id:"stations-and-feeders"}},[o("a",{attrs:{href:"#stations-and-feeders","aria-hidden":"true"}},[o("span",{staticClass:"icon icon-link"})]),t._v("Stations and Feeders")]),o("p",[t._v("In Sensors Connectivity there are two entities: station and feeder.")]),o("h3",{attrs:{id:"station"}},[o("a",{attrs:{href:"#station","aria-hidden":"true"}},[o("span",{staticClass:"icon icon-link"})]),t._v("Station")]),o("p",[t._v("Station represents a source of data. The package can handle many inputs simultaneously:")]),o("pre",[o("code",{pre:!0},[t._v("station1 \\                        / output1\nstation2 -  sensors-connectivity  - output2\nstation3 /                        \\ output3\n")])]),o("p",[t._v("There are COM Station and TCP Station implemented. The first one reads data from a sensor that is connected to a serial port. TCP Station starts a tcp server and listens to incoming connections. ")]),o("p",[t._v("TCP Station can accept data from every sensor or you can specify an access control list (ACL) for known sensors only.")]),o("h3",{attrs:{id:"feeder"}},[o("a",{attrs:{href:"#feeder","aria-hidden":"true"}},[o("span",{staticClass:"icon icon-link"})]),t._v("Feeder")]),o("p",[t._v("Feeder is an output in terms of sensors connectivity:")]),o("pre",[o("code",{pre:!0},[t._v("input1 \\                        / feeder1\ninput2 -  sensors-connectivity  - feeder2\ninput3 /                        \\ feeder3\n")])]),o("p",[t._v("At current implementation the package can publish data to "),o("a",{attrs:{href:"https://meine.luftdaten.info/",target:"_blank",rel:"nofollow noopener noreferrer"}},[t._v("Luftdaten")]),t._v(", Robonomics or Robonomics on Substrate (using Datalog feature).")]),o("h2",{attrs:{id:"connectivity-configuration"}},[o("a",{attrs:{href:"#connectivity-configuration","aria-hidden":"true"}},[o("span",{staticClass:"icon icon-link"})]),t._v("Connectivity Configuration")]),o("p",[t._v("The package is highly configurable. The default configuration file looks like:")]),o("pre",[o("code",{pre:!0,attrs:{class:"language-yaml"}},[t._v('# Please DO NOT edit this file\n# Make a copy instead, make changes and pass the absolute path to the copy in arguments\ngeneral:\n  publish_interval: 300 # time between two published messages\ncomstation:\n  port: "/dev/ttyUSB0"  # COM port of the device\n  work_period: 300      # time between two measurements in seconds\n  geo: ""               # Geo coordinates as latitude,longitude\n  public_key: ""        # If not provided, COMStation creates itself\ntcpstation:\n  address: ""           # IP and PORT to listen to, for example 0.0.0.0:31313\n  acl:                  # list of known addresses. If not specified accepts from everyone\n  # -\n  # -\nluftdaten:\n  enable: true          # whether or not publish to https://luftdaten.info/\nrobonomics:\n  enable: true          # enable use of Robonomics Network\n  ipfs_provider: ""     # ipfs endpoint\n  ipfs_topic: "airalab.lighthouse.5.robonomics.eth"\ndatalog:\n  enable: false         # enable use of Datalog Robonomics subcommand\n  path: ""              # path to Robonomics execution file\n  suri: ""              # private key of publisher account\n  remote: "wss://substrate.ipci.io"\n  dump_interval: 3600   # time between two transactions in seconds\n  temporal_username:    # set to pin files in Temporal.Cloud\n  temporal_password:\ndev:\n  sentry: ""\n')])]),o("p",[t._v("To get familiar with all the options and launch scenarios check the "),o("a",{attrs:{href:"https://github.com/airalab/sensors-connectivity/tree/v0.2",target:"_blank",rel:"nofollow noopener noreferrer"}},[t._v("README.md")]),t._v(" out.")])])}),[],!1,null,null,null);"function"==typeof c&&c(f),"function"==typeof u&&u(f);e.default=f.exports}}]);